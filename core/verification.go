package core

/*
#include <ctanker.h>
#include <stdlib.h>
*/
import "C"
import "unsafe"

// This enumeration represents the different identity verification methods available.
type VerificationMethodType uint32

const (
	VerificationMethodEmail           VerificationMethodType = C.TANKER_VERIFICATION_METHOD_EMAIL
	VerificationMethodPassphrase      VerificationMethodType = C.TANKER_VERIFICATION_METHOD_PASSPHRASE
	VerificationMethodVerificationKey VerificationMethodType = C.TANKER_VERIFICATION_METHOD_VERIFICATION_KEY
	VerificationMethodOidcIdToken     VerificationMethodType = C.TANKER_VERIFICATION_METHOD_OIDC_ID_TOKEN
)

// VerificationMethod describes a type of method registered on the Tanker Server by a user.
// It may contains the email registered if Type is a VerificationMethodEmail.
type VerificationMethod struct {
	Type  VerificationMethodType
	Email *string
}

// AttachResult is returned by AttachProvisionalIdentity(). It contains a Tanker
// Status and the verificationMethod the user is required to use to register the identity provided.
type AttachResult struct {
	Status Status
	Method *VerificationMethod
}

// An Email Verification. The VerificationCode is provided to the user
// by email and must be used here with the Email address.
type EmailVerification struct {
	Email            string
	VerificationCode string
}

// An Password Verification. The verificaiton password registered by the user
// should be used here.
type PassphraseVerification struct {
	Passphrase string
}


// A KeyVerification. The unlock key generated by the user should be used here.
type KeyVerification struct {
	Key string
}

// A OidcVerification. The Open ID Connect ID token registered
// by the user should be used here.
type OidcVerification struct {
	OidcIdToken string
}

// Converts a Verificaton* to the C tanker type
func convertVerificationToTanker(verif interface{}) *C.tanker_verification_t {
	result := &C.tanker_verification_t{
		version: 3,
	}

	switch t := verif.(type) {
	case EmailVerification:
		result.verification_method_type = C.TANKER_VERIFICATION_METHOD_EMAIL
		result.email_verification = C.tanker_email_verification_t{
			version:           1,
			email:             C.CString(t.Email),
			verification_code: C.CString(t.VerificationCode),
		}
	case PassphraseVerification:
		result.verification_method_type = C.TANKER_VERIFICATION_METHOD_PASSPHRASE
		result.passphrase = C.CString(t.Passphrase)
	case KeyVerification:
		result.verification_method_type = C.TANKER_VERIFICATION_METHOD_VERIFICATION_KEY
		result.verification_key = C.CString(t.Key)
	case OidcVerification:
		result.verification_method_type = C.TANKER_VERIFICATION_METHOD_OIDC_ID_TOKEN
		result.oidc_id_token = C.CString(t.OidcIdToken)
	}
	return result
}

// Frees the C verification content
func freeVerif(verif *C.tanker_verification_t) {
	switch verif.verification_method_type {
	case C.TANKER_VERIFICATION_METHOD_EMAIL:
		C.free(unsafe.Pointer(verif.email_verification.email))
		C.free(unsafe.Pointer(verif.email_verification.verification_code))
	case C.TANKER_VERIFICATION_METHOD_PASSPHRASE:
		C.free(unsafe.Pointer(verif.passphrase))
	case C.TANKER_VERIFICATION_METHOD_VERIFICATION_KEY:
		C.free(unsafe.Pointer(verif.verification_key))
	case C.TANKER_VERIFICATION_METHOD_OIDC_ID_TOKEN:
		C.free(unsafe.Pointer(verif.oidc_id_token))
	}
}

// RegisterIdentity registers an identity to be unlocked with the provided
// verification, the one used in Start().
// Tanker's status must be StatusIdentityRegistrationNeeded.
func (t *Tanker) RegisterIdentity(verification interface{}) error {
	cverif := convertVerificationToTanker(verification)
	defer freeVerif(cverif)

	_, err := await(C.tanker_register_identity(t.instance, cverif))
	return err
}

// VerifyIdentity Verifies the user's identity with which Start() has been called,
// and starts the session. This function verifies the user's identity based on the
// provided verification. It must be called when the user has started a Tanker
// session on a new device.
func (t *Tanker) VerifyIdentity(verification interface{}) error {
	cverif := convertVerificationToTanker(verification)
	defer freeVerif(cverif)
	_, err := await(C.tanker_verify_identity(t.instance, cverif))
	return err
}

// SetVerificationMethod sets up the provided Verification for the user.
func (t *Tanker) SetVerificationMethod(verification interface{}) error {
	cverif := convertVerificationToTanker(verification)
	defer freeVerif(cverif)
	_, err := await(C.tanker_set_verification_method(t.instance, cverif))
	return err
}

func convertVerificationMethodToTanker(cmethod *C.tanker_verification_method_t) *VerificationMethod {
	if cmethod == nil {
		return nil
	}
	var email *string
	if cmethod.verification_method_type == C.TANKER_VERIFICATION_METHOD_EMAIL {
		dummy := C.GoString(cmethod.email)
		email = &dummy
	}
	return &VerificationMethod{
		Type:  VerificationMethodType(cmethod.verification_method_type),
		Email: email,
	}
}

// GetVerificationMethods returns all the user verification methods available to the user.
// Those have been registered through a call RegisterIdentity(), or SetVerificationMethod()
func (t *Tanker) GetVerificationMethods() ([]VerificationMethod, error) {
	result, err := await(C.tanker_get_verification_methods(t.instance))
	if err != nil {
		return nil, err
	}
	methodList := (*C.tanker_verification_method_list_t)(unsafe.Pointer(result))
	count := (int)(methodList.count)
	goMethods := make([]VerificationMethod, 0, count)
	for i := 0; i < count; i++ {
		cmethod := (*C.tanker_verification_method_t)(unsafe.Pointer(uintptr(unsafe.Pointer(methodList.methods)) + (unsafe.Sizeof(*methodList.methods) * uintptr(i))))
		goMethods = append(goMethods, *convertVerificationMethodToTanker(cmethod))
	}
	C.tanker_free_verification_method_list(methodList)
	return goMethods, nil
}

// AttachProvisionalIdentity attaches a provisional identity to the current user and returns an AttachResult.
// Depending on the result, you may have to call VerifyProvisionalIdentity() to finish the process.
func (t *Tanker) AttachProvisionalIdentity(provisionalIdentity string) (*AttachResult, error) {
	cidentity := C.CString(provisionalIdentity)
	defer C.free(unsafe.Pointer(cidentity))
	result, err := await(C.tanker_attach_provisional_identity(t.instance, cidentity))
	if err != nil {
		return nil, err
	}
	cresult := (*C.tanker_attach_result_t)(result)
	defer C.tanker_free_attach_result(cresult)
	attachResult := &AttachResult{
		Status: Status(cresult.status),
		Method: convertVerificationMethodToTanker(cresult.method),
	}

	return attachResult, err
}

// VerifyProvisionalIdentity verifies an attached provisional identity. Once the provisional identity is verified, every
// resource shared with it can now be decrypted by the user. They also join every group in which the
// provisional identity was a member.
func (t *Tanker) VerifyProvisionalIdentity(verification interface{}) error {
	_, err := await(C.tanker_verify_provisional_identity(t.instance, convertVerificationToTanker(verification)))
	return err
}

// GenerateVerificationKey generates a verification key. The public part is kept by Tanker's server, and
// the private part is returned, which must be kept to verify the user's identity later on.
//
// This is a low level function for specific use-cases only.
func (t *Tanker) GenerateVerificationKey() (*string, error) {
	result, err := await(C.tanker_generate_verification_key(t.instance))
	if err != nil {
		return nil, err
	}
	key := unsafeANSIToString(result)
	return &key, nil
}
